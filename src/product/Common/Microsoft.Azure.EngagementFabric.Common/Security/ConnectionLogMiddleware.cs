// <auto-generated>
// This file is from TLS 1.2+ Everywhere
// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// </auto-generated>

using Microsoft.Azure.EngagementFabric.Common.Telemetry;
using Microsoft.Owin;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Microsoft.Azure.EngagementFabric.Common.Security
{
    public class ConnectionLogMiddleware : OwinMiddleware
    {
        private string provider;

        public ConnectionLogMiddleware(OwinMiddleware next, string provider)
            : base(next)
        {
            this.provider = provider;
        }

        public async override Task Invoke(IOwinContext context)
        {

            var message = new StringBuilder();
            message.AppendLine(DateTimeOffset.UtcNow.ToString("o"));

            if (context.Get<object>("System.Net.HttpListenerContext") is HttpListenerContext ctx && ctx.Request.Url.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase))
            {
                var tlsInfo = ctx.Request.GetTlsInfo();

                message.AppendLine($"Protocol: {tlsInfo.ProtocolName()}");
                message.AppendLine($"Cipher: {tlsInfo.AlgName(tlsInfo.CipherType)} with {tlsInfo.CipherStrength} bits");
                message.AppendLine($"Hash: {tlsInfo.AlgName(tlsInfo.HashType)} with {tlsInfo.HashStrength} bits");
                message.AppendLine($"KE: {tlsInfo.AlgName(tlsInfo.KeyExchangeType)} with {tlsInfo.KeyExchangeStrength} bits");

                // TODO: auth info can be logged here
                //var authInfo = ctx.Request.GetAuthInfo();

                //var result = Secur32Api.SEC_E_OK == Secur32Api.QueryContextAttributes(authInfo.PackedContext, Secur32Api.SECPKG_ATTR_CIPHER_INFO, out var pBuffer);
                //if (result)
                //{
                //    var cipherInfo = Marshal.PtrToStructure<Secur32Api.SecPkgContext_CipherInfo>(pBuffer);
                //}

                //if (pBuffer != IntPtr.Zero)
                //{
                //    Secur32Api.FreeContextBuffer(pBuffer);
                //    pBuffer = IntPtr.Zero;
                //}

                SecurityEventSource.Current.TraceConnectionLogging(this.provider, message.ToString());
            }
            else
            {
                SecurityEventSource.Current.TraceConnectionLogging(this.provider, "HttpListenerContext is not available for logging TlsInfo");
            }

            // Invoke the next Middleware
            await Next.Invoke(context);
        }
    }

    public static class HttpListenerRequestExtension
    {
        public static HttpApi.HTTP_SSL_PROTOCOL_INFO GetTlsInfo(this HttpListenerRequest httpListenerRequest)
        {
            return HttpApi.GetSslProtocolInfo(httpListenerRequest.GetRequestBuffer(),
                httpListenerRequest.GetOriginalBlobAddress());
        }

        public static HttpApi.HTTP_REQUEST_AUTH_INFO GetAuthInfo(this HttpListenerRequest httpListenerRequest)
        {
            return HttpApi.GetAuthInfo(httpListenerRequest.GetRequestBuffer(),
                httpListenerRequest.GetOriginalBlobAddress());
        }

        public static byte[] GetRequestBuffer(this HttpListenerRequest httpListenerRequest)
        {
            return httpListenerRequest.GetPropertyValue<byte[]>("RequestBuffer");
        }

        public static IntPtr GetOriginalBlobAddress(this HttpListenerRequest httpListenerRequest)
        {
            return httpListenerRequest.GetPropertyValue<IntPtr>("OriginalBlobAddress");
        }

        private static T GetPropertyValue<T>(this object obj, string propertyName)
        {
            var objType = obj.GetType();
            var propInfo = objType.GetProperty(propertyName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            return (T)propInfo.GetValue(obj);
        }
    }

    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single class", Justification = "Single file for Connection Logging")]
    public static unsafe class HttpApi
    {
        internal enum HTTP_REQUEST_INFO_TYPE
        {
            HttpRequestInfoTypeAuth,
            HttpRequestInfoTypeChannelBind,
            HttpRequestInfoTypeSslProtocol,
            HttpRequestInfoTypeSslTokenBindingDraft,
            HttpRequestInfoTypeSslTokenBinding
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_REQUEST_INFO
        {
            internal HTTP_REQUEST_INFO_TYPE InfoType;
            internal uint InfoLength;
            internal void* pInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_VERSION
        {
            internal ushort MajorVersion;
            internal ushort MinorVersion;
        }

        internal enum HTTP_VERB : int
        {
            HttpVerbUnparsed = 0,
            HttpVerbUnknown = 1,
            HttpVerbInvalid = 2,
            HttpVerbOPTIONS = 3,
            HttpVerbGET = 4,
            HttpVerbHEAD = 5,
            HttpVerbPOST = 6,
            HttpVerbPUT = 7,
            HttpVerbDELETE = 8,
            HttpVerbTRACE = 9,
            HttpVerbCONNECT = 10,
            HttpVerbTRACK = 11,
            HttpVerbMOVE = 12,
            HttpVerbCOPY = 13,
            HttpVerbPROPFIND = 14,
            HttpVerbPROPPATCH = 15,
            HttpVerbMKCOL = 16,
            HttpVerbLOCK = 17,
            HttpVerbUNLOCK = 18,
            HttpVerbSEARCH = 19,
            HttpVerbMaximum = 20,
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_COOKED_URL
        {
            internal ushort FullUrlLength;
            internal ushort HostLength;
            internal ushort AbsPathLength;
            internal ushort QueryStringLength;
            internal ushort* pFullUrl;
            internal ushort* pHost;
            internal ushort* pAbsPath;
            internal ushort* pQueryString;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct SOCKADDR
        {
            internal ushort sa_family;
            internal byte sa_data;
            internal byte sa_data_02;
            internal byte sa_data_03;
            internal byte sa_data_04;
            internal byte sa_data_05;
            internal byte sa_data_06;
            internal byte sa_data_07;
            internal byte sa_data_08;
            internal byte sa_data_09;
            internal byte sa_data_10;
            internal byte sa_data_11;
            internal byte sa_data_12;
            internal byte sa_data_13;
            internal byte sa_data_14;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_TRANSPORT_ADDRESS
        {
            internal SOCKADDR* pRemoteAddress;
            internal SOCKADDR* pLocalAddress;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_UNKNOWN_HEADER
        {
            internal ushort NameLength;
            internal ushort RawValueLength;
            internal sbyte* pName;
            internal sbyte* pRawValue;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_KNOWN_HEADER
        {
            internal ushort RawValueLength;
            internal sbyte* pRawValue;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_REQUEST_HEADERS
        {
            internal ushort UnknownHeaderCount;
            internal HTTP_UNKNOWN_HEADER* pUnknownHeaders;
            internal ushort TrailerCount;
            internal HTTP_UNKNOWN_HEADER* pTrailers;
            internal HTTP_KNOWN_HEADER KnownHeaders;
            internal HTTP_KNOWN_HEADER KnownHeaders_02;
            internal HTTP_KNOWN_HEADER KnownHeaders_03;
            internal HTTP_KNOWN_HEADER KnownHeaders_04;
            internal HTTP_KNOWN_HEADER KnownHeaders_05;
            internal HTTP_KNOWN_HEADER KnownHeaders_06;
            internal HTTP_KNOWN_HEADER KnownHeaders_07;
            internal HTTP_KNOWN_HEADER KnownHeaders_08;
            internal HTTP_KNOWN_HEADER KnownHeaders_09;
            internal HTTP_KNOWN_HEADER KnownHeaders_10;
            internal HTTP_KNOWN_HEADER KnownHeaders_11;
            internal HTTP_KNOWN_HEADER KnownHeaders_12;
            internal HTTP_KNOWN_HEADER KnownHeaders_13;
            internal HTTP_KNOWN_HEADER KnownHeaders_14;
            internal HTTP_KNOWN_HEADER KnownHeaders_15;
            internal HTTP_KNOWN_HEADER KnownHeaders_16;
            internal HTTP_KNOWN_HEADER KnownHeaders_17;
            internal HTTP_KNOWN_HEADER KnownHeaders_18;
            internal HTTP_KNOWN_HEADER KnownHeaders_19;
            internal HTTP_KNOWN_HEADER KnownHeaders_20;
            internal HTTP_KNOWN_HEADER KnownHeaders_21;
            internal HTTP_KNOWN_HEADER KnownHeaders_22;
            internal HTTP_KNOWN_HEADER KnownHeaders_23;
            internal HTTP_KNOWN_HEADER KnownHeaders_24;
            internal HTTP_KNOWN_HEADER KnownHeaders_25;
            internal HTTP_KNOWN_HEADER KnownHeaders_26;
            internal HTTP_KNOWN_HEADER KnownHeaders_27;
            internal HTTP_KNOWN_HEADER KnownHeaders_28;
            internal HTTP_KNOWN_HEADER KnownHeaders_29;
            internal HTTP_KNOWN_HEADER KnownHeaders_30;
            internal HTTP_KNOWN_HEADER KnownHeaders_31;
            internal HTTP_KNOWN_HEADER KnownHeaders_32;
            internal HTTP_KNOWN_HEADER KnownHeaders_33;
            internal HTTP_KNOWN_HEADER KnownHeaders_34;
            internal HTTP_KNOWN_HEADER KnownHeaders_35;
            internal HTTP_KNOWN_HEADER KnownHeaders_36;
            internal HTTP_KNOWN_HEADER KnownHeaders_37;
            internal HTTP_KNOWN_HEADER KnownHeaders_38;
            internal HTTP_KNOWN_HEADER KnownHeaders_39;
            internal HTTP_KNOWN_HEADER KnownHeaders_40;
            internal HTTP_KNOWN_HEADER KnownHeaders_41;
        }

        internal enum HTTP_DATA_CHUNK_TYPE : int
        {
            HttpDataChunkFromMemory = 0,
            HttpDataChunkFromFileHandle = 1,
            HttpDataChunkFromFragmentCache = 2,
            HttpDataChunkMaximum = 3,
        }

        [StructLayout(LayoutKind.Sequential, Size = 32)]
        internal struct HTTP_DATA_CHUNK
        {
            internal HTTP_DATA_CHUNK_TYPE DataChunkType;
            internal uint p0;
            internal byte* pBuffer;
            internal uint BufferLength;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_SSL_CLIENT_CERT_INFO
        {
            internal uint CertFlags;
            internal uint CertEncodedSize;
            internal byte* pCertEncoded;
            internal void* Token;
            internal byte CertDeniedByMapper;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_SSL_INFO
        {
            internal ushort ServerCertKeySize;
            internal ushort ConnectionKeySize;
            internal uint ServerCertIssuerSize;
            internal uint ServerCertSubjectSize;
            internal sbyte* pServerCertIssuer;
            internal sbyte* pServerCertSubject;
            internal HTTP_SSL_CLIENT_CERT_INFO* pClientCertInfo;
            internal uint SslClientCertNegotiated;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_REQUEST
        {
            internal uint Flags;
            internal ulong ConnectionId;
            internal ulong RequestId;
            internal ulong UrlContext;
            internal HTTP_VERSION Version;
            internal HTTP_VERB Verb;
            internal ushort UnknownVerbLength;
            internal ushort RawUrlLength;
            internal sbyte* pUnknownVerb;
            internal sbyte* pRawUrl;
            internal HTTP_COOKED_URL CookedUrl;
            internal HTTP_TRANSPORT_ADDRESS Address;
            internal HTTP_REQUEST_HEADERS Headers;
            internal ulong BytesReceived;
            internal ushort EntityChunkCount;
            internal HTTP_DATA_CHUNK* pEntityChunks;
            internal ulong RawConnectionId;
            internal HTTP_SSL_INFO* pSslInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct HTTP_REQUEST_V2
        {
            internal HTTP_REQUEST RequestV1;
            internal ushort RequestInfoCount;
            internal HTTP_REQUEST_INFO* pRequestInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct HTTP_SSL_PROTOCOL_INFO
        {
            public uint Protocol;
            public uint CipherType;
            public uint CipherStrength;
            public uint HashType;
            public uint HashStrength;
            public uint KeyExchangeType;
            public uint KeyExchangeStrength;

            public string ProtocolName()
            {
                // https://msdn.microsoft.com/en-us/library/windows/desktop/aa379819(v=vs.85).aspx
                switch (Protocol)
                {
                    case 0x1:
                    case 0x2:
                        return "PCT 1.0";
                    case 0x4:
                    case 0x8:
                        return "PCT 2.0";
                    case 0x10:
                    case 0x20:
                        return "SSL 3.0";
                    case 0x40:
                    case 0x80:
                        return "TLS 1.0";
                    case 0x100:
                    case 0x200:
                        return "TLS 1.1";
                    case 0x400:
                    case 0x800:
                        return "TLS 1.2";
                }

                return $"UNK:{Protocol:X}";
            }

            public string AlgName(uint AlgId)
            {
                switch (AlgId)
                {
                    //
                    // Ciphers
                    //
                    case 0:
                        return "(null)";
                    case 0x6601:
                        return "DES";
                    case 0x6603:
                        return "3DES";
                    case 0x6602:
                        return "RC2";
                    case 0x6801:
                        return "RC4";
                    case 0x6611:
                        return "AES";
                    case 0x660e:
                        return "AES128";
                    case 0x660f:
                        return "AES192";
                    case 0x6610:
                        return "AES256";
                    //
                    // Hashes
                    //
                    case 0x8001:
                        return "MD2";
                    case 0x8002:
                        return "MD4";
                    case 0x8003:
                        return "MD5";
                    case 0x8004:
                        return "SHA1";
                    case 0x800c:
                        return "SHA256";
                    case 0x800d:
                        return "SHA384";
                    case 0x800e:
                        return "SHA512";
                    //
                    // Key Exchange
                    //
                    case 0xa400:
                        return "RSA";
                    case 0xaa01:
                        return "DH";        // ??
                    case 0xaa02:
                        return "DHE";
                    case 0xaa05:
                        return "ECDH";
                    case 0xae06:
                        return "ECDHE";
                    case 0xa001:
                        return "ECMQV";
                }

                return $"UNK:{AlgId:X}";
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct HTTP_REQUEST_AUTH_INFO
        {
            public uint AuthStatus;
            public uint SecStatus;
            public uint Flags;
            public uint AuthType;
            public IntPtr AccessToken;
            public uint ContextAttributes;
            public uint PacketContextLength;
            public uint PackedContextType;
            public IntPtr PackedContext;
            public uint MutualAuthDataLength;
            public IntPtr pMutualAuthData;
        }

        public static HTTP_SSL_PROTOCOL_INFO GetSslProtocolInfo(byte[] memoryBlob, IntPtr originalAddress)
        {
            fixed (byte* pMemoryBlob = memoryBlob)
            {
                var pRequest = (HTTP_REQUEST_V2*)pMemoryBlob;
                long fixup = pMemoryBlob - (byte*)originalAddress;

                for (int i = 0; i < pRequest->RequestInfoCount; i++)
                {
                    var pRequestInfo = (HTTP_REQUEST_INFO*)(fixup + (byte*)&pRequest->pRequestInfo[i]);
                    if (pRequestInfo != null &&
                        pRequestInfo->InfoType == HTTP_REQUEST_INFO_TYPE.HttpRequestInfoTypeSslProtocol)
                    {
                        return Marshal.PtrToStructure<HTTP_SSL_PROTOCOL_INFO>(new IntPtr(pRequestInfo->pInfo));
                    }
                }
            }

            throw new KeyNotFoundException();
        }

        public static HTTP_REQUEST_AUTH_INFO GetAuthInfo(byte[] memoryBlob, IntPtr originalAddress)
        {
            fixed (byte* pMemoryBlob = memoryBlob)
            {
                var pRequest = (HTTP_REQUEST_V2*)pMemoryBlob;
                long fixup = pMemoryBlob - (byte*)originalAddress;

                for (int i = 0; i < pRequest->RequestInfoCount; i++)
                {
                    var pRequestInfo = (HTTP_REQUEST_INFO*)(fixup + (byte*)&pRequest->pRequestInfo[i]);
                    if (pRequestInfo != null &&
                        pRequestInfo->InfoType == HTTP_REQUEST_INFO_TYPE.HttpRequestInfoTypeAuth)
                    {
                        return Marshal.PtrToStructure<HTTP_REQUEST_AUTH_INFO>(new IntPtr(pRequestInfo->pInfo));
                    }
                }
            }

            throw new KeyNotFoundException();
        }
    }

    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:File may only contain a single class", Justification = "Single file for Connection Logging")]
    public static unsafe class Secur32Api
    {
        public const uint SEC_E_OK = 0;
        public const uint SECPKG_ATTR_CIPHER_INFO = 0x64;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct SecPkgContext_CipherInfo
        {
            public uint dwVersion;
            public uint dwProtocol;
            public uint dwCipherSuite;
            public uint dwBaseCipherSuite;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string szCipherSuite;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string szCipher;

            public uint dwCipherLen;
            public uint dCipherBlockLen;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string szHash;
            public uint dwHashLen;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string szExchange;

            public uint dwMinExchangeLen;
            public uint dwMaxExchangeLen;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string szCertificate;

            public uint dwKeyType;
        }

        [DllImport("Secur32.dll")]
        public static extern uint QueryContextAttributes(
            [In] IntPtr phContext,
            [In] uint ulAttribute,
            [Out] out IntPtr pBuffer
        );

        [DllImport("Secur32.dll")]
        public static extern uint FreeContextBuffer([In] IntPtr pvContextBuffer);
    }
}
